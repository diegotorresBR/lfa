<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width; user-scalable=0;"/>
    <h2><p>Algoritmos de Reconhecimento</p></h2>
	<link rel="stylesheet" href="css\estilos.css">

</head>
<body>
<h5>
    <p align="justify">Verificar se uma determinada palavra pertence ou não a uma linguagem é uma das principais questões relacionadas com o estudo de Linguagens Formais. Um “dispositivo de reconhecimento” de uma classe de linguagens pode ser especificado como um modelo de autômato ou como um algoritmo implementável em um computador. Em qualquer caso é importante determinar a “quantidade de recursos” que o dispositivo necessita para realizar o reconhecimento.</p>
    <p align="justify">Os reconhecedores podem ser, basicamente, de dois tipos:</p>
    <ol type="a">
        <li><i>Top-Down ou Preditivo:</i> constrói uma arvore de derivação para a palavra de entrada a partir da raiz, gerando os ramos em direção às folhas.</li>
        <li><i>Bottom-Up:</i> é, basicamente, o oposto do <i>top-down</i>, partindo das folhas e construindo a arvore de derivação em direção a raiz.</li>
    </ol>
    <p align="justify"><h5>Autômato com Pilha como Reconhecedor</h5></p>
    <p align="justify">A construção de reconhecedores usando Autômato com Pilha é relativamente simples e imediata, havendo uma relação quase direta entre as produções da gramática e as transições do autômato. Os algoritmos apresentados são do tipo top-down e simulam a derivação mais à esquerda da palavra a ser reconhecida. A facilidade de não-determinístico é usada para testar diversas produções alternativas da gramática para gerar os símbolos terminais.</font></p>
    <p align="justify"><h5>Autômato com Pilha Descendente</h5></p>
    <p align="justify">É uma forma alternativa de construir um AP a partir de uma Gramática Livre do Contexto. Trata-se de um algoritmo igualmente simples e com o mesmo nível de eficiência. A construção é gerada a partir de uma gramática sem recursão à esquerda e simula a derivação mais à esquerda, como segue:</p>
    <ul>
        <li>Inicialmente, empilha o símbolo inicial;</li>
        <li>Sempre que existir uma variável no topo da pilha, substitui por todas as produções da variável;</li>
        <li>Se o topo da pilha for um terminal, verifica se é igual ao próximo símbolo da entrada.</li>
    </ul>
    <p align="justify"><h5>Algoritmo de Cocke-Younger-Kasami</h5></p>
    <p align="justify">Foi desenvolvido independentemente por Cocke, Younger e Kasami, em 1965. É construído sobre uma gramática na Forma Normal de Chomswky. Gera bottom-up todas as árvores de derivação da entrada em um tempo de processamento proporcional a |w|^3.</font></p>
    <p align="justify">A ideia básica do algoritmo é a construção de uma tabela triangular de derivação, sendo que cada célula representa o conjunto de raízes que pode gerar a correspondente sub-árvore.</font></p>
</h5>
</body>
<h3><a href="unit43.html"><img border="0" align="left"  src="esq.png" style="width:42px;height:42px;border:0"></a></h3>
</html>