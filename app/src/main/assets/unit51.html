<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width; user-scalable=0;"/>
    <h2><p>5.1.Definição</p></h2>
    <style>
        p.main{
            text-align: justify;
        }
    </style>
</head>
<body>
<dh5>
    <p class="main">Um problema de decisão é um problema cuja formulação conduz a apenas duas respostas possíveis: SIM ou NÃO. Exemplo: dadas duas linguagens regulares L1 e L2 quaisquer, é sempre possível determinar se L1 = L2? Para cada par de linguagens considerado, este problema admite apenas uma resposta entre duas possíveis. Uma instância de um problema é um caso particular de um problema geral, com seus argumentos completamente deﬁnidos. Exemplo: dadas a linguagem regular L1 (segue a especiﬁcação de L1) e a linguagem regular L2 (segue a especiﬁcação de L2), será que L1 = L2?</p>
    <p class="main">Se todas as instâncias de um certo problema, para as quais as respostas forem aﬁrmativas (SIM), forem codiﬁcadas sobre um alfabeto Σ qualquer, tal conjunto de cadeias forma uma linguagem  L sobre Σ. Note-se que as instâncias de problemas cuja resposta é negativa não pertencem a L. Se a linguagem assim constituída for recursiva, é sabido que existe pelo menos uma Máquina de Turing que decide L. Ou seja, dada uma instância qualquer do problema, cuja resposta seja desconhecida, será sempre possível determinar se a resposta é aﬁrmativa ou negativa, bastando para isso veriﬁcar se a referida Máquina de Turing aceita ou rejeita a cadeia que representa a instância. A importância deste resultado está no fato de que linguagens que representam problemas gerais, uma vez identiﬁcadas, como sendo recursivas, são tais que permitem a determinação mecânica da solução, qualquer que seja a instância considerada. A mecanização da solução, no caso, é implementada pela Máquina de Turing que aceita L. As linguagens recursivamente enumeráveis, por outro lado, não gozam dessa propriedade. Conforme a sua deﬁnição, as cadeias não pertencentes à linguagem podem tanto ser rejeitadas após uma parada como provocar a execução de uma sequência interminável de movimentações na Máquina de Turing correspondente. Este fenômeno, característico e especíﬁco das linguagens estritamente recursivamente enumeráveis, não ocorre com as outras classes de linguagens anteriormente consideradas. De fato, é possível provar que, qualquer que seja a linguagem regular, livre de contexto ou recursiva em questão, é sempre possível obter um autômato ﬁnito, um autômato de pilha ou uma Máquina de Turing com ﬁta limitada que sempre pára, qualquer que seja a cadeia de entrada. Isso não signiﬁca, no entanto, que não existam reconhecedores desses tipos que eventualmente executem sequências inﬁnitas de movimentações em resposta a alguma cadeia de entrada. Considere-se agora um outro problema, cujas instâncias de resposta aﬁrmativa também possam ser codiﬁcadas como cadeias sobre um certo alfabeto de entrada. Considere ainda que a linguagem formada por essa coleção de cadeias seja do tipo recursivamente enumerável. Isso acarreta a impossibilidade de se veriﬁcar, mecanicamente, se determinada cadeia pertence ou não à linguagem, pois cadeias não pertencentes à linguagem eventualmente poderão provocar uma movimentação interminável da Máquina de Turing correspondente. Logo, torna-se impossível, no caso geral, determinar se um certo problema possui solução, qualquer que seja a instância considerada. Se determinada instância possui resposta SIM (caso em que a cadeia que a representa pertence à linguagem), é fato que a correspondente Máquina de Turing irá parar após um tempo ﬁnito de processamento. Se a resposta é NÃO, sabe-se apenas que o processamento poderá eventualmente parar, rejeitando a entrada, ou então iniciar uma sequência inﬁndável de movimentações. Para um observador externo, não há nenhuma garantia, para qualquer que seja a instância que venha a ser eventualmente considerada, de que o processamento irá parar em algum momento, produzindo algum resultado. Devido a essa característica, as linguagens recursivamente enumeráveis são também denominadas indecidíveis. Problemas cujas representações na forma de linguagens sejam recursivamente enumeráveis são também chamados de problemas indecidíveis. De uma forma geral, os termos “recursivo” e “recursivamente enumerável” são empregados quando se trata de linguagens genéricas, e os termos “decidível” (sinônimo de “recursiva”) e “indecidível” ou “não-decidível” (sinônimos de “recursivamente enumerável”), quando se trata de linguagens que representam problemas.</p>
    <p class="main">O termo decidibilidade refere-se ao estudo das linguagens formais, com vistas à determinação das classes a que estas pertencem. Os termos solucionável, não-solucionável (ou insolúvel) e parcialmente solucionável, também empregados quando se trata de problemas, signiﬁcam, respectivamente, que as correspondentes linguagens são: (i) recursivas, ou seja, podem sempre ser decididas no caso geral; (ii) recursivamente enumeráveis, ou seja, não podem ser decididas no caso geral; e (iii) recursivamente enumeráveis, enfatizando o fato de que pode haver solução para algumas instâncias do problema (ainda que correndo o risco de se esperar indeﬁnidamente por uma resposta). Aplicada ao estudo dos problemas de decisão, a decidibilidade indica se os mesmos são solucionáveis, não-solucionáveis ou parcialmente solucionáveis. É fácil, portanto, justiﬁcar o grande interesse prático que existe por problemas para os quais se possa provar que a linguagem de representação é recursiva. Problemas cuja linguagem de representação seja comprovadamente estritamente recursivamente enumerável, por outro lado, servem sobretudo para demonstrar a inexistência de procedimentos mecânicos (algoritmos) que possam resolvê-los no caso geral. E isso é um resultado teórico excepcional, uma vez que evita o desperdício de recursos na busca de soluções gerais e mostra que determinados problemas não possuem solução, independentemente da tecnologia computacional — atual ou futura — que possa ser empregada na busca de pretensas soluções. Note-se, ﬁnalmente, que o fato de um determinado problema pode ser resolvido no caso geral não signiﬁca que os algoritmos de resolução conhecidos sejam necessariamente eﬁcientes. Em muitas situações, a busca de solução para o caso geral, cuja existência é conhecida através da teoria, pode ser inviabilizada na prática, em virtude do imenso custo associado à sua realização (custo esse reﬂetido, usualmente, no volume de memória necessário ou no tempo de processamento requerido para se chegar às soluções). Por outro lado, a inexistência de solução para um problema no caso geral não signiﬁca que ele não possa ser resolvido para instâncias especíﬁcas ou pré-determinadas, ou, ainda, para conjuntos de instâncias pré-determinadas do problema original.</p>
</dh5>
</body>
</html>